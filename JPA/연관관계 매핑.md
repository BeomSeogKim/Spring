# 연관관계 매핑
연관관계 매핑은 크게 네가지로 분류된다. 
* 다대일[N:1]  @ManyToOne
* 일대다[1:N]  @OneToMany
* 일대일[1:1]  @OneToOne
* 다대다[N:M]  @ManyToMany


연관관계 매핑의 경우 주로 테이블의 특성과 객체의 특성이 달라 어려움이 발생하게 된다.  
테이블의 경우 아래와 같은 특징을 가지고
  * 외래 키 하나로 양쪽 조인 가능
  * 방향이라는 개념이 없음
객체의 경우 아래와 같은 특징을 지닌다.
  * 참조용 필드가 있는 쪽으로만 참조 가능
  * 한쪽만 참조하면 단방향
  * 양쪽이 서로 참조하면 양방향

테이블의 경우 외래 키(FK) 하나로 두 테이블이 연관관계를 맺는다. 하지만 객체의 양방향 관계는 A -> B , B -> A 처럼 참조가 두군데가 생긴다.    
이 둘 중 테이블의 외래키를 관리할 곳을 정해야 하는데, 연관관계의 주인은 외래 키를 관리하는 참조이며 연관관계 주인의 반대편은 외래 키에 영향을 주지 않고
단순 조회만 가능하다는 특징을 가진다.   

4가지 매핑중 일대다의 경우 자주 사용하지 않는 매핑관계이므로 생략..   

### 다대일(ManyToOne)
![image](https://user-images.githubusercontent.com/110332047/187223828-69dbfdc2-24f3-4565-abf9-bc5b1819dc38.png)   
위 그림에서 테이블의 연관관계를 살펴보면 Many에 속하는 MEMBER 테이블에서 TEAM_ID라는 외래키를 쥐고 있다. 따라서 객체 연관관계 설정을 할 때   
Member에서 외래키를 관리할 곳으로 정하는 것이 설계상 매끄럽다. 만약 양방향 매핑을 하고 싶다면 Team 객체에서도 member를 참조하면 된다.  
다만 **외래키를 쥐고 있지 않은 객체에서 데이터를 수정해도 DataBase에는 update가 되지 않는 것을 명심하자**

### 일대일(OneToOne)
![image](https://user-images.githubusercontent.com/110332047/187225432-2f5bc6f5-5558-43e9-bbe5-f01c55aed060.png)   
일대일의 관계에서는 주 테이블이나 대상 테이블 중 외래 키를 선택 가능하다. 다만 외래 키에는 데이터베이스 Unique 제약조건을 추가해야한다.   
위 그림에서는  Member를 외래 키를 관리하는 객체로 설정하였다. 그림에서 볼 수 있듯이 MEMBER 테이블에 UNI 제약조건이 붙은 것을 확인 할 수 있다. 일대일 관계의 경우 
데이터베이스 개발자와 객체지향 개발자가 주로 의견이 갈리는 영역이라고 한다.

* 주 테이블에 외래 키
  - 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
  - 객체지향 개발자 선호
  - JPA 매핑이 편리
  - 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인이 가능함
  - 값이 없으면 외래키에 null을 허용해야함

* 대상 테이블에 외래 키 
  - 대상 테이블에 외래 키가 존재
  - 전통적인 데이터베이스 개발자 선호
  - 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지가 가능함
  - 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨
### 다대다 (ManyToMany)
![image](https://user-images.githubusercontent.com/110332047/187226829-6fab0444-8a21-43a2-935b-99fbfc7d2060.png)   
다대다의 경우 관계형 데이터베이스는 정규화된 테이블 2개로 표현할 수가 없다. 연결 테이블을 추가해 일대다, 다대일 관계로 풀어내야 한다.   
위의 그림에서 볼 수 있듯 Member와 Product 사이에 MemberProduct라는 연결 테이블을 엔티티로 승격시킨 후 1대 다 다대 1 매핑을 진행해야 한다. 
ORDER 테이블을 보게 되면 Member와 Product에 대한 외래키를 가지고 있는 것을 확인할 수 있으며 이 두가지를 PK로 사용하지 않고 의미 없는 값을 PK로 사용하는 것을
확인 할 수 있다. 
